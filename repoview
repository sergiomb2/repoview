#!/usr/bin/python -tt
# -*- coding: utf-8 -*-
##
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# $Id$

import fnmatch
import getopt
import gzip
import kid
import os
import re
import sys
import time

try:
    from cElementTree import iterparse
except ImportError:
    from elementtree.ElementTree import iterparse
    
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
##
# Some hardcoded constants
#
pkgkid = 'package.kid'
pkgfile = '%s.html'
grkid = 'group.kid'
grfile = '%s.group.html'
idxkid = 'index.kid'
idxfile = 'index.html'

VERSION = '0.2'
DEFAULT_TEMPLATEDIR = './templates'

##
# Stolen from routines I wrote for yum
#
class MDParser:
    """
    Main MDParser class that handles file parsing. It acts like an iterator object.
    """
    def __init__(self, filename):
        # Set up mapping of meta types to handler classes 
        handlers = {
            '{http://linux.duke.edu/metadata/common}metadata': PrimaryEntry,
            '{http://linux.duke.edu/metadata/filelists}filelists': FilelistsEntry,
            '{http://linux.duke.edu/metadata/other}otherdata': OtherEntry,
        }
            
        self.total = None
        self.count = 0
        self._handlercls = None

        # Read in type, set package node handler and get total number of
        # packages
        if filename[-3:] == '.gz': fh = gzip.open(filename, 'r')
        else: fh = open(filename, 'r')
        parser = iterparse(fh, events=('start', 'end'))
        self.reader = parser.__iter__()
        event, elem = self.reader.next()
        self._handlercls = handlers.get(elem.tag, None)
        if not self._handlercls:
            raise ValueError('Unknown repodata type "%s" in %s' % (
                elem.tag, filename))
        # Get the total number of packages
        total = elem.get('packages', None)
        self.total = total is None and None or int(total)

    def __iter__(self):
        return self

    def next(self):
        for event, elem in self.reader:
            if event == 'end' and elem.tag[-7:] == 'package':
                self.count += 1
                return self._handlercls(elem)
        raise StopIteration

class BaseEntry:
    def __init__(self, elem):
        self._p = {} 

    def __getitem__(self, k):
        return self._p[k]

    def keys(self):
        return self._p.keys()

    def values(self):
        return self._p.values()

    def has_key(self, k):
        return self._p.has_key(k)

    def __str__(self):
        out = StringIO()
        keys = self.keys()
        keys.sort()
        for k in keys:
            line = u'%s=%s\n' % (k, self[k])
            out.write(line.encode('utf8'))
        return out.getvalue()

    def _bn(self, qn):
        return qn.split('}')[1]
        
    def _prefixprops(self, elem, prefix):
        ret = {}
        for key in elem.attrib.keys():
            ret[prefix + '_' + key] = elem.attrib[key]
        return ret

class PrimaryEntry(BaseEntry):
    def __init__(self, elem):
        BaseEntry.__init__(self, elem)
        # Avoid excess typing :)
        p = self._p

        self.prco = {}
        self.files = {}

        for child in elem:
            name = self._bn(child.tag)
            if name in ('name', 'arch', 'summary', 'description', 'url', 
                    'packager'): 
                p[name] = child.text

            elif name == 'version': 
                p.update(child.attrib)

            elif name in ('time', 'size'):
                p.update(self._prefixprops(child, name))

            elif name in ('checksum', 'location'): 
                p.update(self._prefixprops(child, name))
                p[name + '_value'] = child.text
            
            elif name == 'format': 
                self.setFormat(child)

        p['pkgId'] = p['checksum_value']
        elem.clear()

    def setFormat(self, elem):

        # Avoid excessive typing :)
        p = self._p

        for child in elem:
            name = self._bn(child.tag)

            if name in ('license', 'vendor', 'group', 'buildhost',
                        'sourcerpm'):
                p[name] = child.text

            elif name in ('provides', 'requires', 'conflicts', 
                          'obsoletes'):
                self.prco[name] = self.getPrco(child)

            elif name == 'header-range':
                p.update(self._prefixprops(child, 'rpm_header'))

            elif name == 'file':
                type = child.get('type', 'file')
                path = child.text
                self.files[path] = type

    def getPrco(self, elem):
        members = []
        for child in elem:
            name = self._bn(child.tag)
            members.append(child.attrib)
        return members
        
        
class FilelistsEntry(BaseEntry):
    def __init__(self, elem):
        BaseEntry.__init__(self, elem)
        self._p['pkgId'] = elem.attrib['pkgid']
        self.files = {}
        for child in elem:
            name = self._bn(child.tag)
            if name == 'file':
                type = child.get('type', 'file')
                path = child.text
                self.files[path] = type
        elem.clear()
                
class OtherEntry(BaseEntry):
    def __init__(self, elem):
        BaseEntry.__init__(self, elem)
        self._p['pkgId'] = elem.attrib['pkgid']
        self._p['changelog'] = []
        for child in elem:
            name = self._bn(child.tag)
            if name == 'changelog':
                entry = child.attrib
                entry['value'] = child.text
                self._p['changelog'].append(entry)
        elem.clear()

def _bn(qn):
    try: return qn.split('}')[1]
    except: return qn

emailre = re.compile('<.*?@.*?>')
def _obEmail(text):
    """
    Make spambots' life more difficult by obfuscating all email addresses,
    since RPM metadata is ripe with them.
    """
    if text is None: return None
    mo = emailre.search(text)
    if mo:
        email = mo.group(0)
        remail = email.replace('.', '{*}')
        remail = remail.replace('@', '{%}')
        text = re.sub(email, remail, text)
    return text

quiet = 0
def _say(text, flush=0):
    """
    Unless in quiet mode, output the text passed.
    """
    if quiet: return
    sys.stdout.write(text)
    if flush: sys.stdout.flush()

## Jonathan :)
class Archer:
    """
    This class handles all possible architectures for a package, since
    the listing is done by n-e-v-r.html, and a single release can have more
    than one architecture available, e.g. "src". This is effectively where
    all packages end up being: there are no further sublevels.
    """
    def __init__(self, elem):
        for child in elem:
            name = _qn(child.tag)
            if name == 'arch':
                self.arch == child.text
            elif name == 'time':
                self.time = int(child.get('build', '0'))
            elif name == 'size':
                self.size = int(child.get('package', '0'))
            elif name == 'location':
                self.loc = child.get('href', '#')
            elif name == 'packager':
                self.packager = _obEmail(child.text)

    def getFileName(self):
        """
        Get the basename of the RPM file in question.
        """
        return os.path.basename(self.loc)

    def getTime(self, format='%c'):
        """
        Return the build time of this package in locale format, unless
        passed as format='strformat'.
        """
        return time.strftime(format, time.localtime(self.time))

    def getSize(self):
        """
        You can access the byte size of the package by looking at arch.size,
        but this will return the size in sane units (KiB or MiB).
        """
        kbsize = self.size/1024
        if kbsize/1024 < 1:
            return '%d KiB' % kbsize
        else:
            return '%0.2f MiB' % (float(kbsize)/1024)

class Package:
    """
    A bit of a misnomer -- this is "package" in the sense of repoview, not in 
    the sense of an .rpm file, since it will include multiple architectures.
    """
    def __init__(self, pkg):
        self.n = pkg['name']
        self.e = pkg['epoch']
        self.v = pkg['ver']
        self.r = pkg['rel']
        self.nevr = (self.n, self.e, self.v, self.r)
        self.group = None
        self.arches = {}
        self.changelogs = []
        self.summary = pkg['summary']
        self.description = pkg['description']
        self.url = pkg['url'] is None and '#' or pkg['url']
        self.license = pkg['license']
        self.vendor = pkg['vendor']
        self.checkPackage(pkg)
    
    def checkPackage(self, pkg):
        pkgid = pkg['pkgId']
        if self.arches.has_key(pkgid): return
        arch = Archer(pkg)
        self.arches[pkgid] = arch

    def parseOther(self, changelogs, limit=3):
        if self.changelogs: return
        
        for changelog in changelogs:
            ## I am here, and I am broken! ##
            self.changelogs.append([date, author, entry])
            if i >= limit-1: break
    
    def _parsePrimary(self, elem):
        self.summary = _text(elem, 'summary')
        self.description = _text(elem, 'description')
        self.url = _text(elem, 'url')
        felem = elem.find(_qn('format'))
        self.license = _text(felem, 'license', ns=ns_rpm)
        self.vendor = _obEmail(_text(felem, 'vendor', ns=ns_rpm))
        self.incomplete = 0

    def getChangeLogs(self):
        """
        Get the changelogs in the [c-formatted date, author, entry] style.
        """
        self.changelogs.sort()
        self.changelogs.reverse()
        retlist = []
        for changelog in self.changelogs:
            date, author, entry = changelog
            date = time.strftime('%c', time.localtime(date))
            retlist.append ([date, author, entry])
        return retlist

class GroupFactory(dict):
    """
    A small utility class that extends the dict functionality to aide in
    kid template generation. It contains the groups, keyed by group id.
    """
    def __init__(self):
        dict.__init__(self)
        self.sortedlist = None
        
    def getSortedList(self, showinvisible=0):
        """
        Get the sorted list of groups. The sorting is done by group id 
        in ascending order (locale-specific).
        """
        if self.sortedlist is None:
            grids = []
            for grid in self.keys():
                if self[grid].uservisible or showinvisible:
                    grids.append(grid)
            grids.sort()
            self.sortedlist = []
            for grid in grids:
                self.sortedlist.append(self[grid])
        return self.sortedlist

class Group:
    """
    Contains a list of packages.
    """
    def __init__(self, grid=None, name=None):
        self.packages = []
        self.grid = grid
        self.name = name
        self.sorted = 0
        self.uservisible = 1

    def getSortedList(self, trim=0, nevr=None):
        """
        A utility method for calling from kid templates. This will
        return a sorted list of packages, optionally trimmed since
        on large repositories this list can be very large, and makes
        the display useless. If you pass the trim parameter, you must
        pass the nevr parameter, too, so the it knows around which package
        to trim.
        """
        if not self.sorted:
            nevrlist = {}
            for package in self.packages:
                nevrlist[package.nevr] = package
            keys = nevrlist.keys()
            keys.sort()
            retlist = []
            for nevr in keys:
                retlist.append(nevrlist[nevr])
            self.packages = retlist
            self.sorted = 1
        if not trim or len(self.packages) <= trim: return self.packages
        retlist = []
        for i, pkg in enumerate(self.packages):
            if pkg.nevr == nevr: break
        half = trim/2
        if i - half < 0:
            return self.packages[0:trim]
        if i + half > len(self.packages):
            return self.packages[-trim:]
        return self.packages[i-half:i+half]
        
    def parseGroup(self, elem, namemap):
        """
        Takes a <group> element from comps.xml and takes the needed
        information from it. Since comps is ordered by package name,
        namemap is required to map name to actual packages.
        """
        self.grid = _text(elem, 'id', ns=None)
        ## 
        # This operates under the assumption that English is always first, so
        # if another xml:lang entry is before English, expect things to be
        # weird. :)
        #
        self.name = _text(elem, 'name', ns=None)
        self.description = _text(elem, 'description', ns=None)
        uv = _text(elem, 'uservisible', ns=None)
        if uv is not None and uv.lower() == 'true': self.uservisible = 1
        else: self.uservisible = 0
        pelem = elem.find('packagelist')
        if pelem is None: return
        for item in pelem:
            pkgname = item.text
            if pkgname in namemap.keys():
                self.packages += namemap[pkgname]
                for package in namemap[pkgname]:
                    package.group = self

class RepoView:
    """
    The base class.
    """
    def __init__(self, repodir, ignore=[], xarch=[], force=0, maxlatest=30):
        self.repodir = repodir
        self.ignore = ignore
        self.xarch = xarch
        self.arches = []
        self.force = force
        self.outdir = os.path.join(self.repodir, 'repodata', 'repoview')
        self.packages = {}
        self.groups = GroupFactory()
        self.letters = GroupFactory()
        self.maxlatest = maxlatest
        ##
        # Parse repomd.xml
        #
        self.repodata = {}
        repomd = os.path.join(self.repodir, 'repodata', 'repomd.xml')
        type = 'unknown'
        for event, elem in iterparse(repomd, events=('start','end')):
            if event == 'end':
                elem.clear()
                continue
            tag = _bn(elem.tag)
            if tag == 'data':
                type = elem.get('type', 'unknown')
                self.repodata[type] = {}
            elif tag == 'location':
                self.repodata[type]['location'] = elem.get('href', '#')
            elif tag == 'checksum':
                self.repodata[type]['checksum'] = elem.text
        self._checkNecessity()
        ## Do packages (primary.xml and other.xml)
        self._parsePrimary()
        self._parseOther()
        ## Do groups and resolve them
        if self.repodata.has_key('group'):
            self._parseGroups()

    def _checkNecessity(self):
        """
        This will look at the checksum for primary.xml and compare it to the
        one recorded during the last run in repoview/checksum. If they match,
        the program exits, unless overridden with -f.
        """
        if self.force: return 1
        ## Check and get the existing repoview checksum file
        try:
            chkfile = os.path.join(self.outdir, 'checksum')
            fh = open(chkfile, 'r')
            checksum = fh.read()
            fh.close()
        except IOError: return 1
        checksum = checksum.strip()
        if checksum != self.repodata['primary']['checksum']: return 1
        _say("RepoView: Repository has not changed. Force the run with -f.\n")
        sys.exit(0)

    def _parseGroup(self, loc):
        """
        Utility method for parsing comps.xml.
        """
        _say('parsing comps...', flush=1)
        fh = self._getFileFh(loc)
        namemap = self._getNameMap()
        pct = 0
        for event, elem in iterparse(fh):
            if event == 'start' and elem.tag == 'group':
                pct += 1
                _say('\rparsing comps: %s groups' % pct)
                group = Group()
                group.parseGroup(elem, namemap)
                self.groups[group.grid] = group
            elem.clear()
        _say('...done\n', flush=1)
        fh.close()

    def _getNameMap(self):
        """
        Needed for group parsing: since only package names are listed in
        <comps>, this maps names to package objects. The result is in the
        format: {'pkgname': [pkgobject1, pkgobject2, ...]}.
        """
        namemap = {}
        for pkgid in self.packages.keys():
            package = self.packages[pkgid]
            name = package.n
            if name not in namemap.keys(): 
                namemap[name] = [package]
            else:
                namemap[name].append(package)
        return namemap

    def _parsePrimary(self):
        """
        Utility method for parsing primary.xml and other.xml
        """
        _say('parsing primary...', flush=1)
        pct = 0
        ignored = 0
        parser = MDParser(self.repodata['primary']['location'])
        for i, pkg in enumerate(parser):
            _say('\rparsing primary: %s packages' % pct)
            if pkg['arch'] in self.xarch:
                ignored += 1
                continue
            if pkg['arch'] not in self.arches: self.arches.append(arch)
            pkgid = self._mkpkgid(pkg['name'], pkg['epoch'], pkg['ver'], pkg['rel'])
            if self._checkIgnore(pkgid):
                ignored += 1
                continue
            if self.packages.has_key(pkgid):
                self.packages[pkgid].checkPackage(pkg)
            else:
                package = Package(pkg)
                package.pkgid = pkgid
                self.packages[pkgid] = package
        self.pkgcount = pct
        self.pkgignored = ignored
        _say('...done, %s ignored\n' % ignored, flush=1)
    
    def _checkIgnore(self, pkgid):
        """
        Check if package id (n-e-v-r) matches the ignore globs passed
        via -i.
        """
        for glob in self.ignore:
            if fnmatch.fnmatchcase(pkgid, glob): return 1
        return 0

    def _parseOther(self, loc):
        """
        Utility method to parse other.xml.
        """
        _say('parsing other...', flush=1)
        fh = self._getFileFh(loc)
        pct = 0
        ignored = 0
        for event, elem in ElementTree.iterparse(fh):
            if event == 'start' and elem.tag == _qn('package', ns=ns_other):
                pct += 1
                _say('\rparsing other: %s packages' % pct)
                n = elem.attrib['name']
                (e, v, r) = self._getevr(elem, ns=ns_other)
                pkgid = self._mkpkgid(n, e, v, r)
                if self.packages.has_key(pkgid):
                    package = self.packages[pkgid]
                    package.parseOther(elem)
                else:
                    ignored += 1
            elem.clear()
        _say('...done, %s ignored\n' % ignored, flush=1)
        fh.close()
            
    def _mkpkgid(self, n, e, v, r):
        """
        Make the n-e-v-r package id out of n, e, v, r.
        """
        return '%s-%s-%s-%s' % (n, e, v, r)

    def _getevr(self, elem, ns):
        """
        Utility method to get e-v-r out of the <version> element.
        """
        print elem
        velem = elem.find(_qn('version', ns=ns))
        print velem
        e = velem.get('epoch', '0')
        v = velem.get('ver', '0')
        r = velem.get('rel', '0')
        return (e, v, r)

    def _getLocation(self, elem):
        """
        Find the location of the package in the <package> node.
        """
        lelem = elem.find(_qn('location', ns=ns_repo))
        loc = lelem.get('href', '#')
        return loc

    def _makeExtraGroups(self):
        """
        This is a utility method to create the extra groups. Currently,
        the extra groups are:
        __orphans__: groups not in any other groups
        __latest__: the last 30 packages updated
        letter groups: All packages get grouped by their uppercased first 
                       letter
        Any empty groups are then removed.
        """
        orphans = Group(grid='__orphans__', 
                               name='Packages not in Groups')
        latest = {}
        for i, pkgid in enumerate(self.packages.keys()):
            _say('\rcreating extra groups: %s entries' % i)
            package = self.packages[pkgid]
            if package.group is None:
                package.group = orphans
                orphans.packages.append(package)
            letter = pkgid[0].upper()
            if letter not in self.letters.keys():
                group = Group(grid=letter, name='Letter: %s' % letter)
                self.letters[letter] = group
            self.letters[letter].packages.append(package)
            # btime is number of seconds since epoch, so reverse logic!
            btime = 0
            for arch in package.arches.values():
                if arch.time > btime: btime = arch.time
            if len(latest.keys()) < self.maxlatest:
                latest[btime] = package
            else:
                times = latest.keys()
                times.sort()
                times.reverse()
                oldest = times[-1]
                if btime > oldest:
                    del latest[oldest]
                    latest[btime] = package
        if orphans.packages:
            self.groups[orphans.grid] = orphans
        times = latest.keys()
        times.sort()
        times.reverse()
        lgroup = Group(grid='__latest__', 
                              name='Last %s Packages Updated' % len(times))
        for time in times:
            lgroup.packages.append(latest[time])
        lgroup.sorted = 1
        self.groups[lgroup.grid] = lgroup
        _say('...done\n', flush=1)
        ## Prune empty groups
        for grid in self.groups.keys():
            if not self.groups[grid].packages: del self.groups[grid]

    def _mkOutDir(self, templatedir):
        """
        Remove the existing repoview directory if it exists, and create a
        new one, copying in the layout dir from templates (if found).
        """
        import shutil
        if os.path.isdir(self.outdir):
            _say('deleting old repoview...', flush=1)
            shutil.rmtree(self.outdir)
            _say('done\n', flush=1)
        os.mkdir(self.outdir)
        layoutsrc = os.path.join(templatedir, 'layout')
        layoutdst = os.path.join(self.outdir, 'layout')
        if os.path.isdir(layoutsrc):
            _say('copying layout...', flush=1)
            shutil.copytree(layoutsrc, layoutdst)
            _say('done\n', flush=1)

    def mkLinkUrl(self, object, isindex=0):
        """
        This is a utility method passed to kid templates. The templates use 
        it to get the link to a package, group, or layout object without
        having to figure things out on their own.
        """
        link = '#'
        prefix = ''
        if isindex:
            if self.toplevel: prefix = os.path.join('repodata', 'repoview')
            else: prefix = 'repoview'
        if object.__class__ is str:
            if not isindex and object == idxfile:
                if self.toplevel: link = os.path.join('..', '..', object)
                else: link = os.path.join('..', object)
            else:
                link = os.path.join(prefix, object)
        elif object.__class__ is Package:
            link = os.path.join(prefix, pkgfile % object.pkgid)
        elif object.__class__ is Group:
            link = os.path.join(prefix, grfile % object.grid)
        elif object.__class__ is Archer:
            if isindex and self.toplevel:
                link = os.path.join('..', object.loc)
            else:
                link = os.path.join('..', '..', object.loc)
        return link

    def applyTemplates(self, templatedir, toplevel=0):
        """
        Just what it says. :)
        """
        if not self.packages:
            _say('No packages available.')
            sys.exit(0)
        gentime = time.strftime('%c')
        self.toplevel = toplevel
        self._makeExtraGroups()
        self._mkOutDir(templatedir)
        ## Do groups
        grtmpl = kid.load_template(os.path.join(templatedir, grkid))
        grtmpl.mkLinkUrl = self.mkLinkUrl
        grtmpl.letters = self.letters
        grtmpl.groups = self.groups
        grtmpl.gentime = gentime
        grtmpl.VERSION = VERSION
        for i, grid in enumerate(self.groups.keys()):
            _say('writing groups: %s written\r' % i)
            group = self.groups[grid]
            grtmpl.group = group
            ser = grtmpl.serialize()
            out = os.path.join(self.outdir, grfile % grid)
            fh = open(out, 'w')
            fh.write(ser)
            fh.close()
        _say('\n', flush=1)
        for i, grid in enumerate(self.letters.keys()):
            _say('writing letter groups: %s written\r' % i)
            group = self.letters[grid]
            grtmpl.group = group
            ser = grtmpl.serialize()
            out = os.path.join(self.outdir, grfile % grid)
            fh = open(out, 'w')
            fh.write(ser)
            fh.close()
        _say('\n', flush=1)
        ## Do packages
        pkgtmpl = kid.load_template(os.path.join(templatedir, pkgkid))
        pkgtmpl.mkLinkUrl = self.mkLinkUrl
        pkgtmpl.letters = self.letters
        pkgtmpl.gentime = gentime
        pkgtmpl.VERSION = VERSION
        for i, pkgid in enumerate(self.packages.keys()):
            _say('writing packages: %s written\r' % i)
            package = self.packages[pkgid]
            pkgtmpl.package = package
            ser = pkgtmpl.serialize()
            out = os.path.join(self.outdir, pkgfile % pkgid)
            fh = open(out, 'w')
            fh.write(ser)
            fh.close()
        _say('\n', flush=1)
        ## Do index
        _say('generating index...', flush=1)
        idxtmpl = kid.load_template(os.path.join(templatedir, idxkid))
        idxtmpl.mkLinkUrl = self.mkLinkUrl
        idxtmpl.letters = self.letters
        idxtmpl.groups = self.groups
        idxtmpl.gentime = gentime
        idxtmpl.pkgcount = self.pkgcount
        idxtmpl.pkgignored = self.pkgignored
        idxtmpl.ignore = self.ignore
        self.arches.sort()
        idxtmpl.arches = self.arches
        idxtmpl.xarch = self.xarch
        idxtmpl.VERSION = VERSION
        if self.toplevel: out = os.path.join(self.repodir, idxfile)
        else: out = os.path.join(self.repodir, 'repodata', idxfile)
        ser = idxtmpl.serialize()
        fh = open(out, 'w')
        fh.write(ser)
        fh.close()
        _say('done\n')
        _say('writing checksum...', flush=1)
        chkfile = os.path.join(self.outdir, 'checksum')
        fh = open(chkfile, 'w')
        fh.write(self.checksum)
        fh.close()
        _say('done\n')

def usage(ecode=0):
    print """repoview [-i name] [-x arch] [-k dir] [-t] [-f] [-q] [repodir]
    This will make your repository browseable
    -i name
        Optionally ignore this package -- can be a shell-style glob.
        This is useful for excluding debuginfo packages:
        -i *debuginfo* -i *doc*
        The globbing will be done against name-epoch-version-release, 
        e.g. foo-0-1.0-1
    -x arch
        Optionally exclude this arch. E.g.:
        -x src -x ia64
    -k templatedir
        Use an alternative directory with kid templates instead of
        the default: %s
        The template directory must contain three required template 
        files: index.kid, group.kid, package.kid and the
        "layout" dir which will be copied into the repoview directory.
    -t
        Place the index.html into the top level of the repodir, instead of 
        just in repodata/index.html.
    -f
        Regenerate the pages even if the repomd checksum hasn't changed.
    -q
        Do not output anything except fatal erros.
    repodir
        Where to look for the 'repodata' directory.
    """ % DEFAULT_TEMPLATEDIR
    sys.exit(ecode)

def main(args):
    global quiet
    if not args: usage()
    ignore = []
    xarch = []
    toplevel = 0
    templatedir = DEFAULT_TEMPLATEDIR
    force = 0
    try:
        gopts, cmds = getopt.getopt(args, 'i:x:k:tfqh', ['help'])
        if not cmds: usage(1)
        for o,a in gopts:
            if o == '-i': ignore.append(a)
            elif o == '-x': xarch.append(a)
            elif o == '-k': templatedir = a
            elif o == '-t': toplevel = 1
            elif o == '-f': force = 1
            elif o == '-q': quiet = 1
            else: usage()
        repodir = cmds[0]
    except getopt.error, e:
        print "Error: %s" % e
        usage(1)
    if templatedir is None:
        templatedir = os.path.join(repodir, 'templates')
    rv = RepoView(repodir, ignore=ignore, xarch=xarch, force=force)
    rv.applyTemplates(templatedir, toplevel=toplevel)

if __name__ == '__main__':
    main(sys.argv[1:])
